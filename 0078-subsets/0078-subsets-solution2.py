class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res, subset = [], [] 
        n = len(nums)

        def dfs(i):
            if i >= n:
                res.append(subset.copy())
                return 
                
            # consider the num[i]
            subset.append(nums[i])
            dfs(i+1)

            # not consider the num[i]
            subset.pop()
            dfs(i+1)

        dfs(0)
        return res 

### Intuition and Approach for `subsets`

#### Intuition
# To generate all possible subsets of a given set of numbers, we use a backtracking approach. The idea is to explore all possible combinations by either including or excluding each element of the set. This ensures that we systematically generate every subset.

# #### Approach
# 1. **Initialization**:
#    - Create a result list `res` to store all subsets.
#    - Create a temporary list `subset` to build each subset during the recursion.

# 2. **Depth-First Search (DFS) Function**:
#    - Use a recursive function `dfs(i)` where `i` is the current index in the `nums` array.
#    - **Base Case**: When `i` is greater than or equal to the length of `nums`, add a copy of `subset` to `res` and return.
#    - **Recursive Case**:
#      - **Include the current element**: Add the current element `nums[i]` to `subset`, call `dfs(i+1)`, and then backtrack by removing the current element.
#      - **Exclude the current element**: Directly call `dfs(i+1)` without adding the current element.

# 3. **Final Result**:
#    - Start the DFS process from the first index and return the result list `res` which contains all subsets.

# #### Time Complexity
# - **Exponential Time**: \(O(2^n \cdot n)\), where \(n\) is the number of elements in `nums`.
#   - There are \(2^n\) subsets in total.
#   - Each subset operation takes \(O(n)\) time in the worst case to copy the subset to the result list.

# #### Space Complexity
# - **Exponential Space**: \(O(2^n \cdot n)\) for storing all subsets in the result list.
# - **Recursion Stack**: \(O(n)\), for the maximum depth of the recursion stack.

# This method ensures that all possible subsets are generated by considering every possible combination of elements through systematic inclusion and exclusion decisions during the DFS process.
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res, sol = [], []
        n = len(nums)

        def backtrack(i):
            if i == n:
                 res.append(sol[:])
                 return
            
            # don't pick
            backtrack(i+1)

            # pick 
            sol.append(nums[i])
            backtrack(i+1)
            sol.pop()
            
        backtrack(0)
        return res

### Intuition and Approach for `subsets`

#### Intuition
# To generate all possible subsets of a given set of numbers, we can use a backtracking approach. The idea is to explore all possible combinations by either including or excluding each element of the set. This way, we can systematically generate every subset.

# #### Approach
# 1. **Initialization**:
#    - Create a result list `res` to store all subsets.
#    - Create a temporary list `sol` to build each subset during the recursion.

# 2. **Backtracking Function**:
#    - Use a recursive function `backtrack(i)` where `i` is the current index in the `nums` array.
#    - **Base Case**: When `i` equals the length of `nums`, add a copy of `sol` to `res` and return.
#    - **Recursive Case**:
#      - **Exclude the current element**: Move to the next index without including the current element.
#      - **Include the current element**: Add the current element to `sol`, move to the next index, and then backtrack to explore further subsets without the current element by removing it from `sol`.

# 3. **Final Result**:
#    - Start the backtracking process from the first index and return the result list `res` which contains all subsets.

# #### Time Complexity
# - **Exponential Time**: \(O(2^n \cdot n)\), where \(n\) is the number of elements in `nums`.
#   - There are \(2^n\) subsets in total.
#   - Each subset operation takes \(O(n)\) time in the worst case to copy the subset to the result list.

# #### Space Complexity
# - **Exponential Space**: \(O(2^n \cdot n)\) for storing all subsets in the result list.
# - **Recursion Stack**: \(O(n)\), for the maximum depth of the recursion stack.

# This method ensures that all possible subsets are generated by considering every possible combination of elements through systematic inclusion and exclusion decisions during the backtracking process.